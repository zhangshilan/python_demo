第一部分：协程
第二部分：asyncio模块进行异步编程
第三部分：实战案例

1.协程（微线程）：一种用户态内的上下文切换技术，即通过一个线程实现代码块互相切换执行
协程不是计算机提供，是程序员人为创造。
实现方法：
    -greenlet，早期模块
    -yield关键字
    -asyncio装饰器（3.4）
    -async、await关键字（3.5）【推荐】

1.1 greenlet实现协程
from greenlet import greenlet

def func1():
    print(1)
    gr2.switch()
    print(2)
    gr2.switch()

def func2():
    print(3)
    gr1.switch(()
    print(4)

gr1 = greenlet(func1)
gr2 = greenlet(func2)

gr1.switch()


1.2 yeild关键字
def func1():
    yeild 1
    yeild from func2()
    yeild 2

def func2():
    yeild 3
    yeild 4

f1 = func1()
for item in f1:
    print(item)

1.3 asyncio 遇到io阻塞会自动切换
import asyncio

@asyncio.coroutine
def func1():
    print(1)
    yeild from asyncio.sleep(2)    #遇到IO耗时操作，自动切换到tasks中的其他任务
    print(2)

@asyncio.coroutine
def func2():
    print(3)
    yeild from asyncio.sleep(2)    #遇到IO耗时操作，自动切换到tasks中的其他任务
    print(4)

tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2())
]
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))

1.4 async&await关键字
import asyncio

async def func1():
    print(1)
    await asyncio.sleep(2)    #遇到IO耗时操作，自动切换到tasks中的其他任务
    print(2)

async def func2():
    print(3)
    await asyncio.sleep(2)    #遇到IO耗时操作，自动切换到tasks中的其他任务
    print(4)

tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2())
]
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))